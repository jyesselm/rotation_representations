import sys
sys.path.append("../")

import unittest
import numpy as np
import math
import pandas as pd

import euler, quaternions, util

def get_final_rotation(r, x_deg, y_deg, z_deg):
    r_x = util.rotation_about_x_axis(x_deg)
    r_y = util.rotation_about_y_axis(y_deg)
    r_z = util.rotation_about_z_axis(z_deg)

    r = r.dot(r_z)
    r = r.dot(r_y)
    r = r.dot(r_x)

    return r

def add_euler_angles(e, added):
    new_e = np.array(e)
    for i in range(3):
        new_e[i] += added[i]
        if new_e[i] > 180:
            new_e[i] -= 360
        if new_e[i] < -180:
            new_e[i] += 360

    return new_e

def euler_sum(e):
    sum = abs(e[0]) + abs(e[1]) + abs(e[2])
    return sum

def record_all_rotations():
    f = open("all_euler_rotations.csv", "w")
    f.write("a,b,g,rot_matrix\n")

    # order appears to matter?
    # only works in r_z -> r_y -> r_x
    for i in range(-9, 9):
        for j in range(-9, 9):
            for k in range(-9, 9):
                r_cur = np.eye(3)
                r_cur = get_final_rotation(r_cur, i * 20, j * 20, k * 20)
                f.write(str(i*20) + "," + str(j*20) + "," + str(k*20) + ",")
                f.write(matrix_to_str(r_cur) + "\n")
    f.close()


def find_rotation_degens():
    rotation_map = {}
    df = pd.read_csv("all_euler_rotations.csv")
    for i, r in df.iterrows():
        m = str_to_matrix(r.rot_matrix)
        e_angles = [round(math.degrees(x)) for x in
                    euler.rotation_matrix_to_euler_angles(m)]
        for i in range(3):
            if e_angles[i] == -0.0:
                e_angles[i] = 0.0
        key = " ".join([str(x) for x in e_angles])
        if key not in rotation_map:
            rotation_map[key] = []
        rotation_map[key].append([r.a, r.b, r.g])

    for k,v in rotation_map.iteritems():
        print k +";",
        for e in v:
            print point_to_str(e) + ";",
        print

def matrix_to_str(m):
    """
    converts numpy array that is multidimensional to a string, assumes that
    each column is length 3, this might be an issue later

    :param m: matrix to be convert to string
    :type m: 3x3 np.array

    :returns: stringifed matrix
    :rtype: str

    :examples:

    .. code-block:: python
        >>> from rnamake import basic_io
        >>> m = np.eye(3)
        >>> print m
        [[ 1.  0.  0.]
         [ 0.  1.  0.]
         [ 0.  0.  1.]]

        >>> basic_io.matrix_to_str(m)
        '1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 '

    """
    s = ""
    for i in range(len(m)):
        for j in range(3):
            s += str(float(m[i][j])) + " "

    return s


def point_to_str(p):
    """
    converts numpy array or list into string

    :param p: point to print
    :type  p: np.array

    :returns: string of each element seperated by a space
    :rtype: str

    :examples:

    .. code-block:: python

        >>> from rnamake import basic_io
        >>> p = np.array([0,1,2])
        >>> basic_io.point_to_str(p)
        '0.0 1.0 2.0 '

    """
    return " ".join([str(float(x)) for x in p])


def str_to_matrix(s):
    """
    converts str generated by :func:`matrix_to_str` back into a 3x3 np.array

    :param s: stringifed verision of 3x3 np.array
    :type s: str

    :return: unstringified 3x3 np.array
    :rtype: 3x3 np.array
    """

    m = np.array([float(x) for x in s.split()])
    rows = int(len(m)/3)
    m = m.reshape(rows,3)
    return m


def str_to_point(s):
    """
    converts str generated by :func:`point_to_str` back to a np.array

    :param s: string of np.array
    :type s: str

    :return: unstringifed verision of str back np.array
    :rtype: np.array
    """

    p = np.array([float(x) for x in s.split()])
    return p


def euler_flip(e):
    new_e = np.array(e)
    for i in range(3):
        if e[i] > 0:
            new_e[i] -= 180
        else:
            new_e[i] += 180

    new_e[1] = -new_e[1]
    return new_e

def norm_euler_angles(e):
    new_e = np.array(e)
    for i in range(3):
        if e[i] == 180 or e[i] == -180:
            e[i] = 0

    new_e_2 = euler_flip(new_e)
    sum_e = euler_sum(new_e)
    sum_e_2 = euler_sum(new_e_2)
    #print new_e, new_e_2
    if sum_e_2 < sum_e:
        new_e = new_e_2

    for i in range(3):
        if new_e[i] == 180 or new_e[i] == -180:
            new_e[i] = 0

    if new_e[0] < 0:
        new_e = -new_e
    elif new_e[0] == 0 and new_e[1] < 0:
        new_e = -new_e
    elif new_e[0] == 0 and new_e[1] == 0 and new_e[2] < 0:
        new_e = -new_e


    return new_e


class EulerUnittest(unittest.TestCase):
    def test_random_rotations(self):
        for i in range(1000):
            r = quaternions.random_rotation_matrix()[:3, :3]
            e = euler.rotation_matrix_to_euler_angles(r)
            r_new = euler.euler_angles_to_rotation_matrix(e)
            diff = abs(np.sum(r - r_new)) # compute total difference in each element in matrix
            if diff > 0.001:
                self.fail("could not reproduce matrix from euler angles")

    def test_x_angle_rotations(self):
        r = util.rotation_about_x_axis(20)
        r_cur = np.eye(3)
        expected = [-20, -40, -60, -80, -100, -120, -140, -160, -180,
                    160, 140, 120, 100, 80, 60, 40, 20, 0]
        for i in range(18):
            r_cur = r_cur.dot(r)
            e_angles = [math.degrees(x) for x in
                        euler.rotation_matrix_to_euler_angles(r_cur)]
            #print e_angles
            diff = abs(expected[i] - e_angles[0])
            if diff > 0.001:
                self.fail("cannot reproduce axis angle rotation with euler angles")

    def _test_angle_rotations(self):
        r_x = util.rotation_about_x_axis(20)
        r_y = util.rotation_about_y_axis(20)
        r_z = util.rotation_about_z_axis(20)
        r_cur = np.eye(3)

        expected = [-20, -40, -60, -80, -100, -120, -140, -160, -180,
                    160, 140, 120, 100, 80, 60, 40, 20, 0]

        # order appears to matter?
        # only works in r_z -> r_y -> r_x
        for i in range(9):
            r_cur = r_cur.dot(r_z)
            for j in range(9):
                r_cur = r_cur.dot(r_y)
                for k in range(9):
                    r_cur = r_cur.dot(r_x)

                    e_angles_expected = np.array([expected[i], expected[j], expected[k]])
                    e_angles = [math.degrees(x) for x in
                                euler.rotation_matrix_to_euler_angles(r_cur)]
                    diff = abs(np.sum(e_angles_expected - e_angles))
                    if diff > 0.1:
                        print e_angles, e_angles_expected, i, j, k
                        print r_cur
                        r_new = np.eye(3)
                        r_new_2 = np.eye(3)
                        print get_final_rotation(r_new, 160, 0, -20)
                        print get_final_rotation(r_new_2, 20, 40, 20)
                        #print get_final_rotation(r_new, 160.00000000000003, 5.253667064725771e-15, -19.99999999999999)

                        exit()

    def _test_angle_rotations_2(self):

        expected = [-20, -40, -60, -80, -100, -120, -140, -160, -180,
                    160, 140, 120, 100, 80, 60, 40, 20, 0]
        # order appears to matter?
        # only works in r_z -> r_y -> r_x
        for i in range(-9, 9):
            for j in range(-9, 9):
                for k in range(-9, 9):
                    r_cur = np.eye(3)
                    r_cur = get_final_rotation(r_cur, (i+1)*20, (j+1)*20, (k+1)*20)

                    e_angles_expected = np.array([expected[i], expected[j], expected[k]])
                    e_angles = [math.degrees(x) for x in
                                euler.rotation_matrix_to_euler_angles(r_cur)]

                    diff = abs(np.sum(e_angles_expected - e_angles))
                    if diff > 0.1:



                        exit()

                        sym1 = add_euler_angles(e_angles, [-180, 180, -180])
                        sym2 = add_euler_angles(e_angles, [-180, 180, 180])
                        sym3 = add_euler_angles(e_angles, [-180, -180, -180])
                        if  abs(np.sum(sym1 - e_angles)) < 0.1:
                            continue
                        if abs(np.sum(sym2 - e_angles)) < 0.1:
                            continue
                        if abs(np.sum(sym3 - e_angles)) < 0.1:
                            continue

                        diff_v = sym1 - e_angles
                        if abs(diff_v[0]) < 0.001 and abs(diff_v[1] < 0.0001) and \
                           abs(diff_v[2]) == 180:
                            continue

                        print e_angles, e_angles_expected, i, j, k
                        print e_angles, sym1
                        print e_angles, sym2
                        print e_angles, sym3

                        r_new = np.eye(3)
                        #print get_final_rotation(r_new, e_angles_expected[0],
                        #                         e_angles_expected[1], e_angles_expected[2])

                        for a in range(3):
                            print e_angles[a] - e_angles_expected[a], \
                                e_angles[a] + e_angles_expected[a]

                        exit()

    def _test_euler_angle_norm(self):
        # 60.0 -40.0 100.0 [[-60, 40, -100], [120, 140, 80]]
        e_angle_correct = np.array([60.0, -40.0, 100.0])
        e_angle = np.array([120, 140, 80])

        print norm_euler_angles(e_angle)

    def test_norm_angles_all(self):
        f = open("out")
        lines = f.readlines()
        f.close()

        for l in lines:
            spl = l.split(";")
            angles = [str_to_point(p) for p in spl[:-1]]

            # confirm all degenerate angles give the same normalized euler angle
            norm_angles = []
            for e in angles:
                norm_angles.append(norm_euler_angles(e))

            for i in range(3):
                for j in range(i+1, 3):
                    dist = np.linalg.norm(norm_angles[i] - norm_angles[j])
                    if abs(dist) > 0.01:
                        print angles[i], angles[j]
                        print norm_angles[i], norm_angles[j]
                        #print norm_euler_angles(np.array([0, -160, 120]))
                        self.fail("not the same")

    def test_norm_angles_random(self):
        pass



def main():
    #find_rotation_degens()
    unittest.main()

if __name__ == '__main__':
    main()
